/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use std::fmt;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CK_VERSION {
    pub major: u8,
    pub minor: u8,
}

impl fmt::Display for CK_VERSION {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}", self.major, self.minor)
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CK_SLOT_INFO {
    pub slotDescription: [u8; 64usize],
    pub manufacturerID: [u8; 32usize],
    pub flags: u32,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
}

impl fmt::Display for CK_SLOT_INFO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let slotDescription = String::from_utf8_lossy(&self.slotDescription);
        let manufacturerID = String::from_utf8_lossy(&self.manufacturerID);
        write!(
            f,
            "slotDescription: {slotDescription},
            manufacturerID: {manufacturerID},
            flags: {},
            hardwareVersion: {},
            firmwareVersion: {}",
            self.flags, self.hardwareVersion, self.firmwareVersion
        )
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CK_TOKEN_INFO {
    pub label: [u8; 32usize],
    pub manufacturerID: [u8; 32usize],
    pub model: [u8; 16usize],
    pub serialNumber: [u8; 16usize],
    pub flags: u32,
    pub ulMaxSessionCount: u32,
    pub ulSessionCount: u32,
    pub ulMaxRwSessionCount: u32,
    pub ulRwSessionCount: u32,
    pub ulMaxPinLen: u32,
    pub ulMinPinLen: u32,
    pub ulTotalPublicMemory: u32,
    pub ulFreePublicMemory: u32,
    pub ulTotalPrivateMemory: u32,
    pub ulFreePrivateMemory: u32,
    pub hardwareVersion: CK_VERSION,
    pub firmwareVersion: CK_VERSION,
    pub utcTime: [u8; 16usize],
}

impl fmt::Display for CK_TOKEN_INFO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let label = String::from_utf8_lossy(&self.label);
        let manufacturerID = String::from_utf8_lossy(&self.manufacturerID);
        let model = String::from_utf8_lossy(&self.model);
        let serialNumber = String::from_utf8_lossy(&self.serialNumber);

        write!(
            f,
            "label: {label},
            manufacturerID: {manufacturerID},
            model: {model},
            serialNumber: {serialNumber},
            flags: {},
            ulMaxSessionCount: {},
            ulSessionCount: {},
            ulMaxRwSessionCount: {},
            ulRwSessionCount: {},
            ulMaxPinLen: {},
            ulMinPinLen: {},
            ulTotalPublicMemory: {},
            ulFreePublicMemory: {},
            ulTotalPrivateMemory: {},
            ulFreePrivateMemory: {},
            hardwareVersion: {},
            firmwareVersion: {},
            utcTime: {:?}",
            self.flags,
            self.ulMaxSessionCount,
            self.ulSessionCount,
            self.ulMaxRwSessionCount,
            self.ulRwSessionCount,
            self.ulMaxPinLen,
            self.ulMinPinLen,
            self.ulTotalPublicMemory,
            self.ulFreePublicMemory,
            self.ulTotalPrivateMemory,
            self.ulFreePrivateMemory,
            self.hardwareVersion,
            self.firmwareVersion,
            self.utcTime
        )
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TByteArray {
    pub length: usize,
    pub data: *mut u8,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSlotTokenInfo {
    pub slot_info: CK_SLOT_INFO,
    pub token_info: CK_TOKEN_INFO,
    pub valid: bool,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSlotTokenInfoArray {
    pub count: usize,
    pub slots_info: *mut TSlotTokenInfo,
}

extern "C" {
    pub fn perform_signing(
        input: TByteArray,
        userPIN: *mut ::std::os::raw::c_char,
        keyPairId: *mut ::std::os::raw::c_char,
    ) -> TByteArray;
}

extern "C" {
    pub fn get_slots_info() -> TSlotTokenInfoArray;
}
